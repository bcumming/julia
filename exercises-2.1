2.1-1

2.1-2

see insertionSort.jl, I added a second parameter that is a lambda function for performing the comparison. By default it is a less-than comparison, but by passing (x,y) -> x>y we get the desired algorithm.

2.1-3

See linearSearch.jl for implementation. The routine returns a value in the range [1, length(A)] if v is found, otherwise it returns 0==NIL.

The loop in variant: at the start of iteration i, the value v is not in the subarray A[1...i-1], and pos=NIL.

Initialization: initially, before the first iteration of the loop pos==0, where 0 is our NIL value. This indicates that v has not been found yet, which is true because we haven't started searching.

Maintenance: during an iteration, the current value in A is compared to v, and if they match, pos is set to the current index i and the loop is broken, otherwise it is unchanged. continuing to the next iteration implies that the value has not been found, maintaining the loop invariant.

Termination: the 

2.1-4

Input: A::Array{Integer}    length n
       B::Array{Integer}    length n
       A=[a1, a2, ..., an] and B=[b1, b2, ..., bn] where ai and bi \in {0,1} for all i \in {1, 2, ..., n}. The value represented by A is sum for i=1:n (a_i * 2^(i-1)), and the same for B
Output: C::Array{Integer}   length n+1
       one array, storing the sum of the values represented by A and B, also in binary format


